def path_follow(self):
		if len(self.waypoints) > 0:
			self.goal = self.waypoints[0]
			(d,desired_z) = self.to_waypoint(self.goal[0],self.goal[1])
			if (d < .1):
				self.waypoints.pop(0)
				self.msg = Twist()
				return

			ang_vel = 0
			c = .5
			dist = (desired_z - self.pose.z)

			if  abs(dist) < math.pi:
				ang_vel = c * dist
			else:
				if dist < 0:
					ang_vel = c * (2*math.pi - abs(dist))
				else:
					ang_vel = -1.0 * c * (2*math.pi - abs(dist))


			print "Goal: "+str(self.goal) + " goal_ang: "+ str(desired_z) + " actual: " + str(self.pose.z) +" ang_vel: "+ str(ang_vel)+ "\n d: " + str(d) + " pos: " +str(self.pose.x)+", "+str(self.pose.y)

			lin_vel = 0
			if math.fabs((desired_z - self.pose.z)) < (math.pi/10) or (2*math.pi - abs(dist)) < (math.pi/10):
				lin_vel = min(.3, .2 * d)
			self.msg = Twist(linear = Vector3(x = lin_vel), angular = Vector3(z = ang_vel))
		else:
			print("Done with Path")